{"version":3,"sources":["assets/script/qiuScript/qiuMoveScript.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["// import aduioTools, { engineType } from \"../aduioTools\";\n// import utiltools from \"../utiltools\";\n// import GameManager from \"./GameManager\";\n// import qiuCollisionScript from \"./qiuCollisionScript\";\n\n// const { ccclass, property } = cc._decorator;\n\n// @ccclass\n// export default class qiuMoveScript extends cc.Component {\n\n\n//     @property(cc.Node)\n//     lightyNode: cc.Node = null; \n\n//     private _isCollsion: boolean = false;\n//     set isCollsion(isCollsion: boolean) {\n\n//         this._isCollsion = isCollsion;\n//         if (isCollsion) {\n\n//             // this.lightyNode.scaleX = 0.0;\n//             this.lightyNode.active = false;\n//             this.destroy();\n//         }\n//     }\n\n//     get isCollsion() {\n\n//         return this._isCollsion;\n//     }\n\n//     _isDown: boolean = false;\n//     set isDown(isDonw: boolean) {\n//         this._isDown = isDonw;\n//         if (isDonw) {\n//             this.lightyNode.angle = 90;\n//             this.lightyNode.scaleX = 0.0;\n//             this.node.getComponent(cc.Graphics).destroy();\n\n//             aduioTools.playSimpleAduioEngine(engineType.fire);\n//             // cc.resources.load(\"prefab/rewardAnim\", cc.Prefab , (err , res)=> {\n//             //     if(res) {\n//             //         let rewardAnim = cc.instantiate(res as cc.Prefab);  \n//             //         GameManager.Instance.displayNode.addChild(rewardAnim); \n//             //     }\n//             // })\n//         }\n//     }\n//     get isDown() {\n//         return this._isDown;\n//     }\n//     lastpos: cc.Vec3 = null;\n\n//     lightYMaxScaleX: number = 1.0;\n\n//     UpdataTime = 0;\n//     checkRayTime = 0;\n\n\n//     nodeY:number = 0;\n//     birdNode:cc.Node = null;\n\n//     floatingValue = 0;\n\n//     startRayline = false;\n\n//     onDestroy() {\n\n//     }\n//     onLoad() {\n\n//     }\n\n//     start() {\n//         this.node.addComponent(cc.Graphics);\n//         this.nodeY = this.node.getPosition().y;\n//         this.birdNode = cc.find(\"Canvas/gameNode/gameLayer/TrayNode/birdTray\");\n//         this.floatingValue = 3 + this.getComponent(qiuCollisionScript).index * 0.15;\n//     }\n\n//     update(dt) {\n        \n//         if(!this.isDown) {\n//             this.node.y = this.nodeY + this.birdNode.getPosition().y * this.floatingValue;\n//         }\n\n//         this.checkRayTime += dt;\n//         let nowPos: cc.Vec3 = this.node.position;\n//         if (this.lastpos == null) {\n//             this.lastpos = nowPos;\n//             return\n//         }\n//         this.UpdataTime += dt;\n//         if (this.UpdataTime < 0.1) {\n//             return\n//         }\n\n//         let distance = 0;\n//         let lightyNodeWidth = 0;\n//         let aniTime = 0.1;\n//         if (this.isDown == false) {\n//             distance = nowPos.x - this.lastpos.x;\n//             if (distance > 0) {\n//                 this.lightyNode.angle = 180;\n//             }\n//             else if (distance < 0) {\n//                 this.lightyNode.angle = 0;\n//             }\n//             if (Math.abs(distance) < 100) {\n//                 distance = 0;\n//             }\n\n//             let speed = distance / this.UpdataTime;\n//             lightyNodeWidth = Math.abs(speed) * 1.0 / 2000;\n//             // console.log(speed + \"\");\n//         } else {\n\n//             distance = nowPos.y - this.lastpos.y;\n//             let speed = distance / this.UpdataTime;\n//             lightyNodeWidth = Math.abs(speed) * 1.0 / 500;\n//             // console.log(`this.lightyNode2 ${this.lightyNode}`);\n//         }\n\n\n//         cc.tween(this.lightyNode)\n//             .to(aniTime, { scaleX: Math.min(lightyNodeWidth, this.lightYMaxScaleX) })\n//             .start()\n\n//         this.lastpos = nowPos;\n//         this.UpdataTime = 0;\n//     }\n\n//     raylineCheck() {\n\n//         if(this.startRayline == false) {\n//             return;\n//         }\n//         if (this.checkRayTime < 0.1) {\n//             return\n//         }\n//         this.checkRayTime = 0;\n//         let pos = this.node.getPosition();\n\n//         let worldPoint = this.node.convertToWorldSpaceAR(cc.v2(0,0))\n//         let array = cc.director.getPhysicsManager().rayCast(worldPoint, cc.v2(worldPoint.x , worldPoint.y - 2000), cc.RayCastType.Closest);\n\n//         // console.log(`pos -- ${pos}`);\n//         // let array = cc.director.getPhysicsManager().rayCast(cc.v2(pos.x + cc.winSize.width / 2, pos.y - this.node.height / 2), cc.v2(pos.x + cc.winSize.width / 2, pos.y - this.node.height / 2 - 10 - 2000), cc.RayCastType.Closest);\n//         if (array != null && array.length > 0) { \n//             let iterator =  array[0]; \n//             let g = this.getComponent(cc.Graphics);\n//             g.clear(); \n//             let point = this.node.convertToNodeSpaceAR(iterator.point);\n//             this.drawLineOfDashes(g, cc.v2(0, -this.node.height / 2 - 10), cc.v2(0,  point.y + 10), '#dcdcdc', true, 10, 20);\n//         } \n\n//         // }    \n//     }\n\n//     drawLineOfDashes(g: cc.Graphics, from: cc.Vec2, to: cc.Vec2, color: string = '#ffffff', stroke: boolean = true, length: number = 10, interval: number = 10): void {\n//         if (g) {\n//             //以 from：cc.v2(100, -100), to: cc.v2(500, -500) 为例\n//             // let off = to.sub(from);//向量减法 值为cc.v2(400, -400)\n//             // // console.log('向量减法', off)\n//             // let dir = off.normalize();//向量归一化法  值为cc.v2(0.707。。。, -0.707。。。)\n//             // // console.log('向量归一化法', dir)\n//             // let dis = off.mag();//返回该向量的长度  值为 565.685424949238\n//             // // console.log('向量的长度', dis)\n//             // let delta = dir.mul(length + interval);// 缩放向量，并返回新结果 值为cc.v2(21.213。。。, -21.213。。。)\n//             // // console.log('缩放向量', delta)\n//             // let delta1 = dir.mul(length);   //值为cc.v2(14.142。。。, -14.142。。。)\n//             // // console.log('缩放向量', delta1)\n//             // let offset = 0;\n//             // let mn = 3;\n//             // if (mn > interval) {\n//             //     offset = mn - interval\n//             // }\n//             // let n = Math.floor(dis / (length + interval));\n//             // g.lineWidth = 5;//线宽\n//             // g.strokeColor.fromHEX(color);//颜色\n//             // if (offset) {\n//             //     n--;\n//             //     g.moveTo(from.x, from.y);\n//             //     let start0 = from.add(cc.v2(dir.x * offset, dir.y * offset));\n//             //     g.circle(start0.x, start0.y, 2);\n//             // }\n//             // from = from.add(cc.v2(dir.x * mn, dir.y * mn))\n//             // for (let i = 0; i < n; ++i) {\n//             //     let start = from.add(delta.mul(i));\n//             //     g.moveTo(start.x, start.y);\n//             //     let end = start.add(delta1);\n//             //     g.circle(end.x, end.y, 2);\n//             // }\n//             // let start1 = from.add(delta.mul(n));\n//             // g.moveTo(start1.x, start1.y);\n//             // if (length < dis - (length + interval) * n - mn) {\n//             //     let end = start1.add(delta1);\n//             //     g.circle(end.x, end.y, 2);\n//             // } else {\n//             //     g.circle(to.x, to.y, 2);\n//             // }\n//             // if (stroke) g.stroke();\n\n//             let startPos = from;\n//             let endPos = to;\n//             let line = endPos.sub(startPos);\n//             let lineLenth = line.mag();\n//             let unitLenth = 20;\n//             let increment = line.normalize().mul(unitLenth);\n//             let drawLine = true;\n//             let pos = startPos.clone();\n//             // g.strokeColor = cc.Color.WHITE;\n//             g.lineWidth = 5;//线宽\n//             g.strokeColor.fromHEX(color);//颜色\n\n//             for (; lineLenth > unitLenth; lineLenth -= unitLenth) {\n//                 if (drawLine) {\n//                     g.moveTo(pos.x, pos.y);\n//                     pos.addSelf(increment);\n//                     g.circle(pos.x, pos.y,2);\n//                     g.stroke();\n//                 } else {\n//                     pos.addSelf(increment);\n//                 }\n//                 drawLine = !drawLine;\n//             }\n\n//             //最后一段\n//             if (drawLine) {\n//                 g.moveTo(pos.x, pos.y);\n//                 g.circle(endPos.x, endPos.y,2);\n//                 g.stroke();\n//             }\n//         }\n//     }\n// }\n"]}